<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Astral Chaser - Match 3 Demo (Diagonal Swap & Match)</title>
  <link rel="stylesheet" href="styles.css">
  
</head>
<body>
  <h1>Astral Chaser: Match-3 Demo</h1>
  <div class="info">Swap adjacent gems to match 3 or more of the same color!</div>
  <div id="score">Score: 0</div>
  <div id="timer">Time: 10.0</div>
  <div id="board"></div>
  <button id="resetBtn">Reset Board</button>
  <script>
    // --- GAME SETTINGS ---
    const size = 8; // 8x8 board
    const colors = [
      {name: "Yellow", code: "#FFEB3B"},
      {name: "Red", code: "#E53935"},
      {name: "Green", code: "#43A047"},
      {name: "Blue", code: "#1E88E5"},
      {name: "Purple", code: "#9C27B0"}
    ];

    // --- GAME STATE ---
    let board = [];
    let score = 0;
    let selected = null; // {row, col}
    let animating = false; // Prevent input during animation

    // --- TIMER STATE (COUNTDOWN) ---
    const TIMER_START = 10000; // 10 seconds in ms
    let timerInterval = null;
    let timerPaused = false;
    let timeLeft = TIMER_START; // ms
    let lastTick = null;
    let gameOver = false;
    // --- DOM ELEMENTS ---
    const boardDiv = document.getElementById('board');
    const scoreDiv = document.getElementById('score');
    const timerDiv = document.getElementById('timer');
    const resetBtn = document.getElementById('resetBtn');

    // --- TIMER FUNCTIONS ---
    function formatTime(ms) {
      const sec = Math.floor(ms / 1000);
      const tenths = Math.floor((ms % 1000) / 100);
      return `${sec}.${tenths}`;
    }

    function updateTimerDisplay() {
      timerDiv.textContent = "Time: " + formatTime(Math.max(timeLeft, 0));
    }

    function startTimer() {
      if (timerInterval) return;
      timerPaused = false;
      lastTick = Date.now();
      timerInterval = setInterval(() => {
        if (!timerPaused && !gameOver) {
          const now = Date.now();
          const dt = now - lastTick;
          lastTick = now;
          timeLeft -= dt;
          if (timeLeft <= 0) {
            timeLeft = 0;
            updateTimerDisplay();
            stopTimer();
            handleGameOver();
            return;
          }
          updateTimerDisplay();
        }
      }, 100);
    }

    function stopTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
    }

    function pauseTimer() {
      if (!timerPaused && !gameOver) {
        timerPaused = true;
        // Adjust timeLeft for time spent since lastTick
        const now = Date.now();
        timeLeft -= Math.max(0, now - lastTick);
        updateTimerDisplay();
      }
    }

    function resumeTimer() {
      if (timerPaused && !gameOver) {
        timerPaused = false;
        lastTick = Date.now();
      }
    }

    function resetTimer() {
      stopTimer();
      timeLeft = TIMER_START;
      timerPaused = false;
      gameOver = false;
      updateTimerDisplay();
    }

    function handleGameOver() {
      gameOver = true;
      animating = true;
      timerDiv.textContent = "Time: 0.0 (Game Over)";
      // Optionally, you can disable board input here.
    }

    // --- FUNCTIONS ---
    function randomGem() {
      return Math.floor(Math.random() * colors.length);
    }

    function initBoard() {
      board = [];
      for (let r = 0; r < size; r++) {
        const row = [];
        for (let c = 0; c < size; c++) {
          let gem;
          do {
            gem = randomGem();
            row[c] = gem;
          } while (
            (c >= 2 && row[c-1] === gem && row[c-2] === gem) ||
            (r >= 2 && board[r-1][c] === gem && board[r-2][c] === gem) ||
            // Avoid starting diagonal matches too
            (r >= 2 && c >= 2 && board[r-1][c-1] === gem && board[r-2][c-2] === gem) ||
            (r >= 2 && c <= size-3 && board[r-1][c+1] === gem && board[r-2][c+2] === gem)
          );
        }
        board.push(row);
      }
      score = 0;
      selected = null;
      animating = false;
      gameOver = false;
      updateBoard();
      updateScore();
      resetTimer();
      startTimer();
    }

    function updateBoard() {
      boardDiv.innerHTML = "";
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          const gemDiv = document.createElement('div');
          gemDiv.className = 'gem';
          gemDiv.style.background = colors[board[r][c]].code;
          gemDiv.title = colors[board[r][c]].name;
          gemDiv.dataset.row = r;
          gemDiv.dataset.col = c;
          if (selected && selected.row === r && selected.col === c)
            gemDiv.classList.add('selected');
          gemDiv.onclick = () => selectGem(r, c);
          if (gameOver) gemDiv.style.pointerEvents = "none";
          boardDiv.appendChild(gemDiv);
        }
      }
    }

    function updateScore() {
      scoreDiv.textContent = `Score: ${score}`;
    }

    function selectGem(r, c) {
      if (animating || gameOver) return;
      if (!selected) {
        selected = {row: r, col: c};
        updateBoard();
        return;
      }
      if (selected.row === r && selected.col === c) {
        selected = null;
        updateBoard();
        return;
      }
      // Allow adjacent (including diagonals!) swaps
      const dr = Math.abs(selected.row - r);
      const dc = Math.abs(selected.col - c);
      if ((dr === 1 && dc === 0) || (dr === 0 && dc === 1) || (dr === 1 && dc === 1)) {
        swapGems(selected.row, selected.col, r, c, true);
      } else {
        selected = {row: r, col: c};
        updateBoard();
      }
    }

    function swapGems(r1, c1, r2, c2, checkMatch) {
      [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
      updateBoard();
      if (checkMatch) {
        let matches = findMatches();
        if (matches.length === 0) {
          // Swap back if no match
          setTimeout(() => {
            swapGems(r1, c1, r2, c2, false);
            selected = null;
            updateBoard();
          }, 300);
        } else {
          selected = null;
          resolveMatches(matches);
        }
      }
    }

    // Find all matches: horizontal, vertical, and diagonal
    function findMatches() {
      let matches = [];
      // Horizontal matches
      for (let r = 0; r < size; r++) {
        let run = 1;
        for (let c = 1; c < size; c++) {
          if (board[r][c] === board[r][c-1]) {
            run++;
          } else {
            if (run >= 3) matches.push({row: r, col: c-run, len: run, dir: 'horiz'});
            run = 1;
          }
        }
        if (run >= 3) matches.push({row: r, col: size-run, len: run, dir: 'horiz'});
      }

      // Vertical matches
      for (let c = 0; c < size; c++) {
        let run = 1;
        for (let r = 1; r < size; r++) {
          if (board[r][c] === board[r-1][c]) {
            run++;
          } else {
            if (run >= 3) matches.push({row: r-run, col: c, len: run, dir: 'vert'});
            run = 1;
          }
        }
        if (run >= 3) matches.push({row: size-run, col: c, len: run, dir: 'vert'});
      }

      // Diagonal matches: top-left to bottom-right
      for (let r = 0; r < size-2; r++) {
        for (let c = 0; c < size-2; c++) {
          let gem = board[r][c];
          if (gem === board[r+1][c+1] && gem === board[r+2][c+2]) {
            let len = 3;
            while (r+len < size && c+len < size && board[r+len][c+len] === gem) len++;
            matches.push({row: r, col: c, len: len, dir: 'diag1'});
          }
        }
      }
      // Diagonal matches: bottom-left to top-right
      for (let r = 2; r < size; r++) {
        for (let c = 0; c < size-2; c++) {
          let gem = board[r][c];
          if (gem === board[r-1][c+1] && gem === board[r-2][c+2]) {
            let len = 3;
            while (r-len >= 0 && c+len < size && board[r-len][c+len] === gem) len++;
            matches.push({row: r, col: c, len: len, dir: 'diag2'});
          }
        }
      }

      // Filter duplicates (if a match covers cells already in another match)
      // We'll merge all matches into a mask for removal.
      let mask = Array.from({length: size}, () => Array(size).fill(false));
      for (const m of matches) {
        for (let k = 0; k < m.len; k++) {
          if (m.dir === 'horiz') mask[m.row][m.col + k] = true;
          else if (m.dir === 'vert') mask[m.row + k][m.col] = true;
          else if (m.dir === 'diag1') mask[m.row + k][m.col + k] = true;
          else if (m.dir === 'diag2') mask[m.row - k][m.col + k] = true;
        }
      }
      // Rebuild matches array to only include unique matched cells
      let finalMatches = [];
      for (let r = 0; r < size; r++)
        for (let c = 0; c < size; c++)
          if (mask[r][c]) finalMatches.push({row: r, col: c});
      // If no matches, return []
      if (finalMatches.length === 0) return [];
      // To work with resolveMatches, we build a pseudo-match array
      return [{cells: finalMatches}];
    }

    function resolveMatches(matches) {
      // Pause timer while animating
      pauseTimer();
      animating = true;
      // Build a mask of matched cells
      let matched = Array.from({length: size}, () => Array(size).fill(false));
      if (matches.length && matches[0].cells) {
        for (const cell of matches[0].cells) {
          matched[cell.row][cell.col] = true;
        }
      }
      // Animate matched gems (fade out)
      Array.from(boardDiv.children).forEach((div, i) => {
        let r = Math.floor(i/size), c = i%size;
        if (matched[r][c]) div.style.filter = 'brightness(3) grayscale(0.8)';
      });
      setTimeout(() => {
        // Remove matched gems and drop others down
        for (let c = 0; c < size; c++) {
          let newCol = [];
          for (let r = size-1; r >= 0; r--) {
            if (!matched[r][c]) newCol.push(board[r][c]);
          }
          while (newCol.length < size) newCol.push(randomGem());
          for (let r = size-1; r >= 0; r--) {
            board[r][c] = newCol[size-1 - r];
          }
        }
        // Score update: 10 points per removed gem
        let removed = 0;
        for (let r = 0; r < size; r++)
          for (let c = 0; c < size; c++)
            if (matched[r][c]) removed++;
        score += removed * 10;
        updateScore();
        updateBoard();
        // Check for new matches (cascade)
        setTimeout(() => {
          let newMatches = findMatches();
          if (newMatches.length > 0) {
            resolveMatches(newMatches);
          } else {
            animating = false;
            // Resume timer after all matches have resolved
            resumeTimer();
          }
        }, 200);
      }, 300);
    }

    // --- INIT ---
    resetBtn.onclick = initBoard;
    initBoard();
  </script>
</body>
</html>